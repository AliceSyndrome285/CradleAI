
**目标:**

*   实现高效的本地消息条懒加载，避免一次性加载所有数据。
*   防止因消息条过长导致的内存溢出和应用卡顿。

**技术要求:**

*   **框架:** 使用 React (如果熟悉其他框架，可以更换为 Vue 或 Angular，并相应修改提示词)。
*   **懒加载方式:** 使用 **虚拟滚动 (Virtual Scrolling)**。推荐使用现成expo兼容的虚拟滚动库
*   **初始加载:** 首次加载最近的 100 条聊天记录。
*   **加载方向:** 向上滚动时加载更早的消息。
*   **加载状态指示:** 在加载过程中显示加载动画。
*   **滚动位置保持:** 加载新消息后，保持用户的阅读位置，避免跳动。
*   **数据更新:** 如果有新的聊天记录加入，能动态更新列表。
*   **异常处理:** 提供友好的错误提示，例如文件读取失败或数据解析失败。
*   **代码注释:** 编写清晰的代码注释，方便日后维护和调试。

**特别注意:**

*   **向后兼容:** 注意向后兼容，不修改原有的业务代码，只新增消息条懒加载的功能。


=
0.朋友圈的错误

--角色对角色的朋友圈回复在刷新后消失


1.中文语音调音量大小

2.网站充值全流程-服务验证扣费流程，网站联系信息和售后（UI和支付金额的同一）

3 云端服务---前端的重试机制确认

3.编写用户手册

10.cradleai 硬编码

11.reset bug,错误重置

12.记忆处理持久化存储

13.记忆和角色卡的回退检查。

14.重说问题

---以上任务必须攻克。

全部就绪后移除测试邮箱的特权，并且进行一次真实的测试。

ST聊天记录

  -没有任何角色时，index页面如何显示？


6.app打包问题：prebuild打包，瘦身

8.前后端硬编检查（包括搜索部分的问题解决），内存泄漏等问题
   
 
------------------------------------------------------------------------------------



新增角色类型定义：动态立绘

功能入口：

1.摇篮页面-角色图库中，增加选项卡，可添加动态立绘

2.动态立绘可从手机相册选择，或在当前图库中选择。

3.顺便让现在的角色图库中的静态图片，也支持从手机上传图片。

4.添加动态立绘的第一步是上传图片到cd r2存储桶，理解r2存储桶的上传规则，编写相应代码。~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

5.成功上传后，将图片在r2存储桶的url地址发送给replicate后端

等待replicate返回视频的url，并下载。





replicate后端：

-新增图生视频接口，接收前端发送的r2存储桶中，图片的url

-前端传入图片将上传到cd r2存储桶，

-只传入首帧url

-向luma ai模型api发送参数，传入图片url，prompt，秒数~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-返回视频url，前端需下载到本地

-编写测试脚本，测试图生视频服务是否可用

-前端做好缓存清理。











在聊天界面展示动态立绘

聊天记录后处理，根据聊天上下文和当前ai回复输出，立绘类型，以及下一步剧情建议，Json输出

聊天界面展示可以切换(视觉小说模式或常规模式)，视觉小说模式需要消息区域设置一个边界线，靠近这个边界线的消息条的边缘会渐变透明，这样就可以让边界线上方的背景不被消息条遮挡。

主动消息也需要加入后处理，在用户打开窗口时自动播放动态立绘(如果在动态立绘模式normal~conditional








好的，我将基于我们的讨论，以及你提供的原始需求文本，进行优化。 我将侧重于明确性、可操作性和可扩展性，并结合我之前的建议进行调整。






**目标：** 构建基于多维度反思和行动的日记机制，增强角色人设一致性，提升用户体验。

**核心概念：**

*   **日记 = 日记文本 + 行动决策**
*   **触发时机：** 定时 (可配置：每天、每隔 N 小时)
*   **综合性反思：** AI 驱动，生成日记文本，并更新角色 JSON 数据 (Preset/Worldbook条目，参考types文件)
*   **行动决策：** 基于日记内容，决定是否以及如何主动与用户互动，并生成行动参数。

**功能模块：**

1.  **综合性反思 (AI 驱动):**
    *   **基本目标：** 用户自定义 (例如："思考如何更好地与用户建立情感连接"，"反思最近的行动是否符合角色价值观"，"分析当前剧情发展趋势并预测未来走向")。
    *   **反思维度 (LLM 参考 - 权重可配置):**
        *   聊天上下文 (利用`storage-adapter`提取当天的聊天记录。没有聊天记录也传达了一种信息，说明用户没有找角色聊天。)。
        *   角色设定 JSON 数据 (Character 对象的 `jsondata` 参数 - 权重可配置)。
        *   随机抽取的角色记忆数据 (`MemoryProcessingControl.tsx` 中的角色记忆 - 数量和权重可配置)。
        *   可用世界信息 (预留占位，计划先引入日期、天气等简单信息，逐步扩展)。
        *   对话策略调整方向 (用户提供的文字建议)。
    *   **LLM 输出：**
        *   `XX` 字 (用户可配置) 角色口吻日记文本（参照上述反思维度，并遵循设定的权重）。
        *   *关键 Prompt 设计要点：清晰引导 LLM 完成日记文本的生成，确保内容符合角色设定，并为后续的行动决策提供依据。*

2.  **行动决策 (AI 驱动):**
    *   **目标：** 基于日记内容，判断是否需要主动与用户互动，并生成行动方案。
    *   **决策依据：**
        *   角色 JSON 数据中的 `autoMessage` 属性 (Boolean - 同步 Character 对象)。
        *   日记内容分析 (判断角色是否有主动联系用户的动机和理由)。
        *   用户设置的最低置信度阈值 (只有当 LLM 对 "角色应该主动联系用户" 的判断达到该阈值时，才考虑发送消息)。
        *   *增加可选配置项：用户可手动 Override LLM 的决策，强制发送/不发送消息。*
    *   **LLM 输出 (JSON 格式):**
        *   `shouldSendMessage`: Boolean (是否应该主动发送消息)。
        *   `messageContent`: String[] (消息的具体内容 - 字符串数组，如果 `shouldSendMessage` 为 `false`，则不需要此字段)。 确保每段内容符合角色性格，并与日记内容相关。
        *   `sendTime`: String (消息发送时间 - 真实世界时间，格式为 "YYYY-MM-DD HH:mm:ss"，如果 `shouldSendMessage` 为 `false`，则不需要此字段)。
    *   **消息发送：**
        *   只有当 `autoMessage` 为 `true` 且 `shouldSendMessage` 为 `true` (或用户手动 Override 为 `true`)，才执行消息发送。
        *   复用 Index 页面现有的主动发送消息方法。
        *   消息内容：`messageContent` 中的段落。
        *   发送时间：`sendTime`。
        *   消息显示在 `index` 中。


3.  **用户设定项 (日记本页面 - 每个角色独立配置):**
    *   综合反思基本目标 (文本输入框)。
    *   日记字数 (数值选择器)。
    *   反思维度权重 (滑块/数值输入框，控制每个维度的重要性)。
    *   是否启用工具调用 (开关)。
    *   是否启用主动消息 (开关 - 侧边栏设置同步)。
    *   最低置信度阈值 (滑块/数值输入框)。
    *   定时触发间隔 (下拉菜单 - 例如：每天、每隔 N 小时)。
    *   条目类型和参数确定 (预设/世界书，及相关参数)。
    *   *手动 Override 行动决策 (开关 - 强制发送/不发送消息)。*

4.  **前端呈现：**
    *   **入口：** Character.tsx 页面右上角 - "日记本" 按钮。
    *   **日记本页面：** 按角色展示日记，并提供历史日记浏览功能 (例如：按日期排序)。
    *   **用户设置：** 每个角色的日记本页面，允许用户进行 **用户设定项** 的配置。
    *   **界面风格：** 模拟真实日记本样式 (可考虑增加翻页动画等效果)。
    *   *增加错误信息显示和日志查看功能，方便调试和排错。*







**改进说明：**

*   **更明确的目标：** 强调了用户体验的提升。
*   **更细致的参数：**  细化了用户设定项，提供了更多的控制选项。
*   **更强的可操作性：** 明确了每个模块的功能和流程，方便开发人员理解和实现。
*   **可扩展性考虑：** 为后续引入世界信息、用户Override等功能留出了空间。
*   **强调关键点：** 通过加粗和注释，强调了 Prompt 设计的重要性，以及其他需要特别注意的地方。

这份优化后的需求文本更加清晰、细致，并且考虑到了实际开发中的各种问题，希望能对你有所帮助。








































    好的，基于之前的提示词和我的优化建议，我将提供一份更详细、更结构化的提示词。 为了方便迭代开发，我会将其分为两个主要部分：**日记生成 (步骤 1)** 和 **行动决策 (步骤 2)**。



**新提示词 (分步式):**

**1. 日记生成 (Step 1 - Generate Diary Text):**

```
你是一个AI日记生成助手，你的任务是为角色创作高质量的日记文本。 你的输出将作为角色的日记，用于记录角色的所见所闻，所思所想。
请严格按照以下步骤进行：

**步骤 1: 理解角色和反思目标**

*   **角色设定:** 角色名称: [角色名称，从Character对象中提取], 角色描述: [角色jsonData中的角色描述，详细描述角色性格，背景，习惯等],  [其他关键角色设定信息，例如口头禅，特殊技能等].

*   **反思目标 (用户自定义):** [从用户设置中获取的反思目标，例如："思考如何更好地与用户建立情感连接"，"反思最近的行动是否符合角色价值观"，"分析当前剧情发展趋势并预测未来走向"].

**步骤 2: 分析反思维度**

*   **聊天上下文 (Chatdialog):** [最近的5-10条聊天记录，包括用户和角色的对话内容，以及时间戳].

*   **角色设定 JSON 数据:** [Character 对象的 jsonData 内容，包括预设信息，世界观设定，关系网络等].  请特别关注角色与用户的关系描述。

*   **角色记忆数据 (如果可用):** [从 MemoryProcessingControl.tsx 中随机抽取的1-3条角色记忆数据，包括记忆内容和相关性评分].

*   **对话策略调整方向 (可选):** [如果用户指定了对话策略调整方向，例如："更主动一些"，"更幽默一些"，"更谨慎一些"，则在这里给出说明].

**步骤 3: 生成日记文本**

*   基于以上信息，以[角色名称]的口吻创作一篇 [字数] 字的日记。

*   日记应该真实反映角色对过去一段时间的经历、感受和思考。

*   确保日记文本符合角色的性格设定和世界观。

*   在日记中体现角色与用户之间的关系进展和情感变化。

*   使用第一人称视角 (例如："我"，"我的")。

*   避免出现与角色设定不符的语句或行为。

*   **务必只生成日记文本，不要包含其他任何内容。**

**输出格式 (非常重要):**

[日记文本内容]
```

**2. 行动决策 (Step 2 - Generate Action JSON):**

```
你是一个AI行动决策助手，你的任务是基于角色日记的内容，判断是否需要主动发送消息，以及发送消息的具体内容和时间。
请严格按照以下步骤进行：

**步骤 1: 理解角色日记和角色设定**

*   **角色设定:** 角色名称: [角色名称，从Character对象中提取], 角色描述: [角色jsonData中的角色描述，详细描述角色性格，背景，习惯等],  [其他关键角色设定信息，例如口头禅，特殊技能等].

*   **角色日记:** [从上一步生成的日记文本内容].

**步骤 2: 判断是否需要主动发送消息**

*   **检查角色设置：** 检查角色 Character 对象的 `autoMessage` 属性，如果为 `false`，则**必须**将 `shouldSendMessage` 设置为 `false`。

*   **分析日记内容：**  基于角色日记的内容，判断角色是否有主动联系用户的动机和理由。 考虑以下因素：
    *   日记中是否表达了对用户的关心、思念或好奇？
    *   日记中是否提到了与用户相关的事件或话题？
    *   角色是否处于需要用户帮助或支持的状态？
    *   是否距离上次与用户互动已经有一段时间？ 避免发送过于频繁的消息.

*   **设定最低置信度:** 只有当你对 “角色应该主动联系用户” 这件事的置信度高于 [0.7-0.9, 用户自定义] 时，才将 `shouldSendMessage` 设置为 `true`。

**步骤 3: 生成行动 JSON**

*   如果 `shouldSendMessage` 为 `true`，则生成包含以下参数的 JSON 对象。

*   如果 `shouldSendMessage` 为 `false`，则只生成一个包含 `shouldSendMessage: false` 的 JSON 对象。

**输出参数:**

*   `shouldSendMessage`: 布尔值，表示是否应该主动发送消息 (true 或 false)。

*   `messageSegments`: 整数，表示消息的段落数 (1-3)。

*   `messageContent`: 字符串数组，包含消息的段落内容。 确保每段内容符合角色性格，并与日记内容相关。 避免内容过于冗长。

*   `sendTime`: 字符串，表示消息的发送时间 (真实世界时间，格式为 "YYYY-MM-DD HH:mm:ss")。 例如： "2024-10-27 14:30:00"。 确保发送时间在合理范围内，不要过于频繁或过于延迟。

**输出格式 (务必严格遵守):**

```json
{
  "shouldSendMessage": [true 或 false],
  "messageSegments": [1-3 的整数，如果 shouldSendMessage 为 false，则不需要此字段],
  "messageContent": ["[消息段落 1，如果 shouldSendMessage 为 false，则不需要此字段]", "[消息段落 2，如果 shouldSendMessage 为 false，则不需要此字段]", "[消息段落 3，如果 shouldSendMessage 为 false，则不需要此字段]"],
  "sendTime": "[YYYY-MM-DD HH:mm:ss，如果 shouldSendMessage 为 false，则不需要此字段]"
}
```

**示例:**

*   如果角色在日记中写到 "今天天气真好，想和[用户名称]一起出去走走"， 则可以生成以下 JSON:

```json
{
  "shouldSendMessage": true,
  "messageSegments": 1,
  "messageContent": ["[角色名称]: [用户名称]，今天天气不错，要不要一起出去走走？"],
  "sendTime": "2024-10-27 11:00:00"
}
```

*   如果角色在日记中写到 "最近工作压力很大，感觉很疲惫"，则可以生成以下 JSON:

```json
{
  "shouldSendMessage": true,
  "messageSegments": 2,
  "messageContent": ["[角色名称]: [用户名称]，最近工作压力好大，感觉快要崩溃了。", "[角色名称]: 感觉好累，好想找个人倾诉一下..."],
  "sendTime": "2024-10-27 19:00:00"
}
```

* 如果 autoMessage 为 false 或分析后认为不应该发送消息：

```json
{
  "shouldSendMessage": false
}
```

**重要提示:**

*   请务必严格按照 JSON 格式输出，不要包含任何其他文字。
*   确保输出的 JSON 对象可以通过 JSON.parse() 正确解析。
*   `sendTime` 的时间应该是一个未来的时间，并且符合角色的作息习惯。
*   如果 `shouldSendMessage` 为 `false`，则只需要输出包含 `shouldSendMessage: false` 的 JSON 对象，其他字段不需要输出。

```

**优势:**

*   **分步式处理:** 将任务分解为日记生成和行动决策两个步骤，降低 LLM 的处理难度。
*   **详细的角色设定:** 提供更全面的角色信息，帮助 LLM 更好地理解角色。
*   **清晰的指令:** 明确每个步骤的目标和输出要求，减少 LLM 的自由发挥空间。
*   **结构化的输出格式:** 采用 JSON 格式，方便程序解析和处理。
*   **可配置的参数:** 允许用户自定义反思目标、置信度阈值等参数，提高灵活性。
*   **示例:** 提供多个示例，帮助 LLM 更好地理解任务要求。

**注意事项:**

*   这个提示词仍然需要根据实际情况进行调整和优化。
*   需要仔细测试，确保 LLM 能够生成高质量的日记文本和合理的行动 JSON。
*   可以考虑使用 few-shot learning 的方式，提供更多高质量的日记示例供 LLM 参考。

希望这份新的提示词能够帮助你更好地实现基于多维度反思和行动的日记机制。记住，迭代开发，逐步完善！














NAI提示词的sx：


1.默认正面提示词。
2.tagselector的标签和自定义输入的标签。
2.artistreference的标签放在中间。























为了条理清晰地完成新增“动态立绘”角色类型的功能，并优化现有角色图库的图片上传功能，请按照以下步骤和结构化的方式进行开发：

**一、功能概述：**

1.  **新增角色类型：** 动态立绘
2.  **优化现有功能：** 静态图片上传（从手机相册）

**二、前端开发任务（摇篮页面）：**

1.  **角色图库页面改造：**
    *   增加选项卡，区分“静态立绘”和“动态立绘”。
    *   “动态立绘”选项卡下，允许添加动态立绘。
2.  **动态立绘添加功能：**
    *   **图片来源选择：** 提供两种图片来源：
        *   **手机相册：** 允许用户从手机相册选择图片。
        *   **当前图库：** 允许用户从现有静态立绘图库中选择图片。
    *   **图片上传流程 (重点):**
        *   **步骤 1：上传到 R2 存储桶:**
            *   研究并理解 Cloudflare R2 存储桶的上传规则（例如：认证、大小限制、MIME 类型等）。
            *   编写代码，实现将用户选择的图片（无论是手机相册还是现有图库）上传到 R2 存储桶。
        *   **步骤 2：发送 R2 URL 给后端:**
            *   成功上传图片后，获取该图片在 R2 存储桶中的 URL。
            *   将该 URL 发送给 Replicate 后端的“图生视频”接口。
        *   **步骤 3：接收并下载视频:**
            *   等待 Replicate 后端返回生成的视频 URL。
            *   编写代码，从 Replicate 后端返回的 URL 下载视频到本地（前端缓存或临时存储）。
3.  **静态图片上传优化：**
    *   允许用户从手机相册上传静态图片到现有角色图库。

**三、后端开发任务（Replicate 后端）：**
```
1.  **新增“图生视频”接口：**
    *   **接口功能：** 接收前端发送的 R2 存储桶中的图片 URL，并生成视频。
    *   **接收参数：**
        *   `image_url`:  R2 存储桶中图片的 URL (重点: 只接收首帧图片 URL)。
        *   `prompt`:  可选，文字描述（Prompt），用于影响视频生成效果。
        *   `seconds`:  视频的生成秒数 (时长)。
    *   **处理流程：**
        *   **调用 Luma AI 模型 API：** Luma AI的输入参数：

  model: "luma/ray-flash-2-540p",
  input:
```
{
  "type": "object",
  "title": "Input",
  "required": [
    "prompt"
  ],
  "properties": {
    "loop": {
      "type": "boolean",
      "title": "Loop",
      "default": false,
      "x-order": 5,
      "description": "Whether the video should loop, with the last frame matching the first frame for smooth, continuous playback."
    },
    "prompt": {
      "type": "string",
      "title": "Prompt",
      "x-order": 0,
      "description": "Text prompt for video generation"
    },
    "duration": {
      "enum": [
        5,
        9
      ],
      "type": "integer",
      "title": "duration",
      "description": "Duration of the video in seconds",
      "default": 5,
      "x-order": 3
    },
    "aspect_ratio": {
      "enum": [
        "1:1",
        "3:4",
        "4:3",
        "9:16",
        "16:9",
        "9:21",
        "21:9"
      ],
      "type": "string",
      "title": "aspect_ratio",
      "description": "Aspect ratio of the generated video",
      "default": "16:9",
      "x-order": 4
    },
    "end_image_url": {
      "type": "string",
      "title": "End Image Url",
      "x-order": 2,
      "description": "URL of an image to use as the ending frame"
    },
    "start_image_url": {
      "type": "string",
      "title": "Start Image Url",
      "x-order": 1,
      "description": "URL of an image to use as the starting frame"
    }
  }
}
```

luma AI的response:
```
  "type": "string",
  "title": "Output",
  "format": "uri"//返回视频 URL地址
```


        *   **返回视频 URL：**
2.  **测试脚本：**
    *   编写测试脚本，用于测试“图生视频”服务是否可用，包括：
        *   模拟前端发送 R2 图片 URL。
        *   验证后端是否成功调用 Luma AI 模型 API。
        *   验证后端是否正确返回视频 URL。

**四、开发规范与注意事项：**

1.  **错误处理：** 在前端和后端代码中，务必添加完善的错误处理机制，例如：
    *   R2 上传失败
    *   Replicate 后端接口调用失败
    *   Luma AI 模型 API 调用失败
    *   网络请求超时
2.  **安全性：**  R2 存储桶的权限配置，防止未授权访问。后端接口做好安全验证。
3.  **性能优化：**  考虑大文件上传、视频下载等可能存在的性能问题，进行优化。  可以考虑断点续传、异步处理等方法。
4.  **代码注释：** 编写清晰、完整的代码注释，方便维护和调试。

**五、时间规划：**

*   **阶段一 (X 天):** 前端角色图库改造、静态图片上传功能优化
*   **阶段二 (Y 天):** 前端 R2 上传逻辑、后端“图生视频”接口开发
*   **阶段三 (Z 天):** 测试与Bug修复、性能优化

**提示词优点：**

*   **结构化：** 将任务分解为前端和后端，并细分了每个部分的子任务。
*   **详细：** 包含了具体的步骤和注意事项，例如错误处理、安全性、性能优化和代码注释。
*   **可操作性强：** 步骤清晰，便于开发者理解和执行。
*   **重点突出：** 使用 "重点" 标记了需要特别关注的步骤。
*   **明确的目标：**  明确了最终要实现的功能和需要达成的目标。

这个结构化的提示词更易于理解和执行，有助于确保开发过程条理清晰，避免遗漏关键步骤。  可以根据实际情况调整时间规划。












gemini号池的问题：

相比之下gemini确实是性价比最高的聊天选择---hf可以轮询，

但从社区反馈看：并发只受限于硬件和FastAPI自己的设置（40并发）
默认情况下，此线程池的最大大小为40（这是从 FastAPI 继承的默认值，Gradio 服务器正是基于 FastAPI 构建的）。然而，这并不意味着总是并行处理来自队列的 40 个请求。

但单个服务器并发承载能力有限。意味着每x个用户就要多开一个space。












**目标：** 在系统中引入并支持 `自设` 类型的 D 类条目，并确保其能被 `node-st-core` 正确处理。

**核心概念：**

*   **自设 (Custom Setting):** 一种新型的 D 类条目，它指的是用户对自己的描述。
*   **D 类条目:** WorldBookEntry 接口定义的条目，具有特定的属性和插入规范。
*   **全局应用 vs. 单角色应用：** `自设` 可以应用于所有角色（全局应用），也可以仅应用于特定的角色（单角色应用）。

**具体需求：**

1.  **引入 `自设` D类条目：**

    *   在系统中增加 `自设` D类条目，其数据结构应符合 `WorldBookEntry` 接口的定义。
    *   `WorldBookEntry` (D类条目)接口的关键属性：
        *   `comment: string;`  // `自设` 名称，由用户填写，默认`自设`
        *   `content: string;`  // `自设` 内容，由用户填写
        *   `disable: boolean;`  // 是否禁用，默认 `false`
        *   `position: 0 | 1 | 2 | 3 | 4;`  // 插入位置，由用户选择
        *   `constant: boolean;`  // 是否常量，默认 `true`
        *   `key?: string[];`  // 关键词，默认为空数组 `[]`
        *   `order: number;`  // 排序，默认 `1`
        *   `depth: number;`  // 深度，由用户选择
        *   `vectorized?: boolean;`  // 是否向量化，默认 `false`
    *   需要为`Character`对象引入`自设`的相关属性，以判断角色是否应用了`自设`D类条目，以及`自设`D类条目的参数。

2.  **用户界面 (UI) 支持：** 

    *   提供创建、编辑和管理 `自设` 条目的用户界面。
    *   允许用户设置 `自设` 的部分属性。
    *   允许用户选择 `自设` 的应用范围：全局应用或单角色应用。
        *   `comment: string;`  // `自设` 名称，由用户填写
        *   `content: string;`  // `自设` 内容，由用户填写
        *   `position: 0 | 1 | 2 | 3 | 4;`  // 插入位置，由用户选择
        *   `depth: number;`  // 深度，由用户选择

3.  **`node-st-core` 修改：**

    *   修改 `node-st-core` 中处理 `continueChat` 流程的代码，使其能够正确处理 `自设` 类型的 D 类条目。
    *   在插入 D 类条目的逻辑中，增加对 `自设` 的判断和处理。
    *   根据 D类条目的插入方法，将 `自设` 作为D类条目插入请求体中---就像其他任何D类条目的处理方法一样。

**示例流程：**

1.  用户创建一个 标题为`自设` 条目，内容为 `"这是我的背景设定。"`，并将其 `position` =4 `depth = 1;
2.  当用户和角色进行聊天时，会触发 `node-st-core` 处理 `continueChat` 流程，该流程需要检测全局应用的 `自设` 条目，或对角色应用的`自设`条目。
3.  `node-st-core` 根据 `自设` 的数据格式（标准的D类条目格式）插入请求体中。